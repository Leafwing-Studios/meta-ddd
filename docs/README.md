# Introduction

Document Driven Design (DDD) is an **SDLC** framework that specifies that you **create the documentation before building the software.** Teams begin by doing **rapid prototyping** on their documentation, with different members from different specialties bringing **proposals, constraints,** and **perspectives** to the table. The group provides **honest, critical feedback** to develop, improve, and refine proposals for how individual pieces of the system should work. Once a proposal is accepted, someone from the team must **document precisely** how the feature or system functions. The documentation must be sufficient to later code the functionality with little to no additional information. **Because explaining the function of a system is much cheaper and faster than actually programming it, the team is much more free to remove or change older systems** that no longer work, have bugs that weren't originally caught, or are no longer up to the standards of the team.

DDD is constructed to ensure that **problems and consequences are discovered and fixed before any code is written.** When prototyping, **lab tests** are conducted to gain more information about the problem, and the viability of potential solutions. These tests both ensure this early discovery, and provide reference when actually building. Additionally when prototyping, proposed systems are **unit tested** on pen and paper (or in some other lightweight lab environment) to ensure they are robust. The system must be functional before being put into a computer. 

After the documentation is relatively stable, development begins. Developers follow the solutions and systems in the documentation, which has already been extensively vetted and tested. When changes are made (or more specifics are determined by the exact implementation), the developer makes a **pull request.** In these requests, **the documentation updates are investigated as closely as the code updates.**

When unforeseen issues are discovered during development, the process starts over. The team **removes what doesn't work** (and any knock-on effects) and starts the documentation process from scratch with the new information. This is more expensive to do once code has been written, but yields the **best solutions.** DDD is constructed to ensure this happens only rarely. 

Teams and companies running DDD are typically much **flatter and more resource-flexible** than traditional teams. Projects are split at a conceptual level based on abstraction. Employee resources are allocated based on who is better at **abstract** vs **concrete** problem solving, *not* based on rank or salary.	Employees can expect to be moved between different teams within the same project as their skill sets become relevant to those pieces.
